<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm | 一位有匠心的手艺人]]></title>
  <link href="http://guevara.github.io/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://guevara.github.io/"/>
  <updated>2014-09-14T11:14:03+08:00</updated>
  <id>http://guevara.github.io/</id>
  <author>
    <name><![CDATA[bingo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[快速平方根倒数算法]]></title>
    <link href="http://guevara.github.io/blog/2014/07/14/fast-inverse-square-root/"/>
    <updated>2014-07-14T19:27:00+08:00</updated>
    <id>http://guevara.github.io/blog/2014/07/14/fast-inverse-square-root</id>
    <content type="html"><![CDATA[<div class="note info">
  <h5>摘要</h5>
  <p>本文揭示了《雷神之锤&#8546;：竞技场》中的一段快速平方根倒数算法和魔法常数的可能值。算法使用一些bit hack技巧快速计算得32位浮点数的平方根倒数的近似值。</p>
</div>

<p><blockquote><p>玄之又玄，众妙之门</p></blockquote></p>

<script type="math/tex; mode=display">
    \frac{1}{\sqrt{x}} \tag{*}
</script>

<center>&#8258;</center>

<p>``` c Quake III: Arena q_math.c
float Q_rsqrt( float number )
{
    long i;
    float x2, y;
    const float threehalfs = 1.5F;</p>

<pre><code>x2 = number * 0.5F;
y  = number;
i  = * ( long * ) &amp;y;                       // evil floating point bit level hacking
i  = 0x5f3759df - ( i &gt;&gt; 1 );               // what the fuck?
y  = * ( float * ) &amp;i;
y  = y * ( threehalfs - ( x2 * y * y ) );   // 1st iteration //  y  = y * ( threehalfs - ( x2 * y * y ) );   // 2nd iteration, this can be removed

return y; } ```
</code></pre>

<p>这段朴素又平凡的代码出现《雷神之锤Ⅲ：竞技场》源码<code>quake3-1.32b/code/game/q_math.c</code>的548~572行，
既不包含循环迭代，也没有除法运算，只涉及简单的浮点数和整数运算。 代码的41~43行分别预告本文的三个小节</p>

<ul>
  <li>初值确定与误差分析</li>
  <li>浮点数的表示及运算</li>
  <li>牛顿逼近</li>
</ul>

<center>&#8258;</center>

<h4 id="section">1. 起源</h4>

<p>浮点数平方根倒数常用于矢量正规化（标准化）。正规化矢量，先计算其欧氏范数即矢量长度</p>

<script type="math/tex; mode=display">
\|\boldsymbol{v}\| = \sqrt{v_{i}^2+v_{j}^2+v_{k}^2}
</script>

<p>作为分母除诸分量即得到与原矢量同方向的 <strong>单位矢量</strong> ，</p>

<script type="math/tex; mode=display">
\boldsymbol{\hat{v}} = \frac{\boldsymbol{v}} {\|\boldsymbol{v}\|}
</script>

<p>可见浮点数平方根倒数为矢量正规化必要过程。三维图形程序利用正规化矢量来实现光照和投影效果，每秒会进行百万次平方根倒数运算。
为了加速图像处理单元计算，《雷神之锤Ⅲ：竞技场》采用了平方根倒数速算法来实现，</p>

<p>``` c q_math.c
void VectorNormalizeFast( vec3_t v )
{
    float ilength;</p>

<pre><code>ilength = Q_rsqrt( DotProduct( v, v ) );

v[0] *= ilength;
v[1] *= ilength;
v[2] *= ilength; } ```
</code></pre>

<p>后来现场可编程逻辑门阵列的顶点着色器也应用了此算法。</p>

<h4 id="section-1">2. 分析</h4>

<h5 id="c">2.1 四行C++整蛊代码背后的秘密</h5>

<p><code>cpp C++Sucks  http://ideone.com/PM4qan C++Sucks 
#include &lt;stdio.h&gt;
double m[]= {7709179928849219.0, 771};
int main()
{
    m[1]--?m[0]*=2,main():printf((char*)m);
}
</code>
运行输出<code>C++Sucks</code>。</p>

<p>将代码格式化为可读版本</p>

<p>``` cpp
double m[2] = {7709179928849219.0, 771};
// m[0] = 7709179928849219.0;
// m[1] = 771;</p>

<p>int main()
{
    if (m[1]–)
    {
        m[0] <em>= 2;
        main();
    }
    else
    {
        printf((char</em>) m);
    }
}
```</p>

<p><code>main()</code>函数递归调用自身771次。开始<code>m[0] = 7709179928849219.0</code>对应字符串<code>C++Suc;C</code>，<code>m[0]</code>每调用一轮即翻一倍，改变末尾两个字符（二进制的指数部分）。
直到最后一轮调用，<code>m[0]</code>包含<code>C++Sucks</code>的ASCII字符串，而<code>m[1]</code>只包含0。消除递归重构程序主体为循环语句，使代码逻辑更清晰了然：</p>

<p><code>cpp
double m[] = {7709179928849219.0, 0};
for (int i = 0; i &lt; 771; i++)
{
    m[0] *= 2;
}
printf((char*) m);
</code></p>

<p>最终代码将浮点数按位解释为字符串，并打印输出。</p>

<h5 id="section-2">2.1.1 浮点数的内部表示</h5>

<p>浮点数IEEE754的标准格式</p>

<table>
    <tbody>
        <tr>
            <th><small>S(ign,符号)</small></th>
            <th><small>E(xponent,指数)</small></th>
            <th><small>M(antissa,尾数)</small></th>
        </tr>
        <tr style="text-align:center;">
            <td>1 bit</td>
            <td>b bits</td>
            <td><tt>(n-1-b)</tt>bits</td>
        </tr>
        <tr>
            <td colspan="3" style="text-align:center;">n bits</td>
        </tr>
    </tbody>
</table>

<ul>
  <li>S 尾数符号，0正1负</li>
  <li>M 尾数, 纯小数的原码表示</li>
  <li>E 指数（阶码），采用“移码”表示（移码可表示阶符） </li>
</ul>

<h5 id="section-3">2.1.2 浮点数的规格化</h5>

<ul>
  <li>隐藏位</li>
</ul>

<p>原码非0值浮点数的尾数数值最高位必为1，通过尾数移位强行去掉该位，则同样多的位数能多保存一位，从而提高数值精度。</p>

<p>同样，还原浮点数时，必须先恢复该隐藏位。</p>

<ul>
  <li>移码</li>
</ul>

<p>对于64位双精度浮点数<code>7709179928849219.0</code>，先将整数和分数部分转换成二进制</p>
<pre>
7709179928849219.0 
= 00011011 01100011 01110101 01010011 00101011 00101011 01000011.0
      ---- -------- -------- -------- -------- -------- --------
</pre>

<p>小数点向左移动52位即</p>
<pre>
1.1011 01100011 01110101 01010011 00101011 00101011 01000011 * 2^52
</pre>
<p><script type="math/tex">e = 52</script>，<script type="math/tex">E = 2^{10} -1 + 52 = 2^{10} + 51 = 10000110011</script>，得到二进制形式：</p>
<pre>
01000011 00111011 01100011 01110101 01010011 00101011 00101011 01000011
+^^^^^^^ ^^^^---- -------- -------- -------- -------- -------- --------
</pre>

<p><code>+</code>为符号位，<code>^</code>部分代表指数，<code>-</code>部分代表尾数(去掉指数剩下的值)。
对于指数和尾数二进制表示，数值翻倍意味着指数自增一。程序执行<code>771</code>次，指数从<code>1075</code>开始（<code>10000110011</code>的十进制表示）累加至<code>1075 + 771 = 1846</code>终止。<code>1846</code>的二进制表示是<code>11100110110</code>，生成模式串：</p>

<pre>
01110011 01101011 01100011 01110101 01010011 00101011 00101011 01000011
-------- -------- -------- -------- -------- -------- -------- --------
0x73 's' 0x6B 'k' 0x63 'c' 0x75 'u' 0x53 'S' 0x2B '+' 0x2B '+' 0x43 'C'
</pre>

<p>在<strong>小端模式</strong>下模式串与打印输出一一对应，只不过顺序相反。数组的第二个元素同时递减至零即终止符<code>\0</code>，与第一个元素构成完整字符串传给<code>printf</code>。</p>

<p>上述代码与平台有关，并利用了以下未定义的事实：</p>

<ul>
  <li>字符串长8字节，恰好为双精度浮点数机器字长</li>
  <li>字节序（端序）</li>
</ul>

<h5 id="bit-hack">题外: bit hack</h5>

<p>按位（bitwise）解释</p>

<ul>
  <li>减少循环（比较）次数</li>
  <li>增加单位操作量</li>
  <li>有效利用内存对齐原则，减少访问时钟周期</li>
</ul>

<h6 id="memcpy">例一. memcpy优化</h6>

<p>glibc</p>

<p>``` c memcpy http://code.metager.de/source/xref/gnu/glibc/string/memcpy.c
#define BYTE_COPY_FWD(dst_bp, src_bp, nbytes)    <br />
do                                        \
    {                                         \
      if (src_bp % OPSIZ == 0)                            \
    _wordcopy_fwd_aligned (dst_bp, src_bp, (nbytes) / OPSIZ);        \
      else                                    \
    _wordcopy_fwd_dest_aligned (dst_bp, src_bp, (nbytes) / OPSIZ);       \
      src_bp += (nbytes) &amp; -OPSIZ;                        \
      dst_bp += (nbytes) &amp; -OPSIZ;                        \
      (nbytes_left) = (nbytes) % OPSIZ;                       \
    } while (0)
void *
memcpy (dstpp, srcpp, len)
     void *dstpp;
     const void *srcpp;
     size_t len;
{
  unsigned long int dstp = (long int) dstpp;
  unsigned long int srcp = (long int) srcpp;</p>

<p>/* Copy from the beginning to the end.  */</p>

<p>/* If there not too few bytes to copy, use word copy.  <em>/
  if (len &gt;= OP_T_THRES)
    {
      /</em> Copy just a few bytes to make DSTP aligned.  */
      len -= (-dstp) % OPSIZ;
      BYTE_COPY_FWD (dstp, srcp, (-dstp) % OPSIZ);</p>

<pre><code>  /* Copy whole pages from SRCP to DSTP by virtual address manipulation,
 as much as possible.  */

  PAGE_COPY_FWD_MAYBE (dstp, srcp, len, len);

  /* Copy from SRCP to DSTP taking advantage of the known alignment of
 DSTP.  Number of bytes remaining is put in the third argument,
 i.e. in LEN.  This number may vary from machine to machine.  */

  WORD_COPY_FWD (dstp, srcp, len, len);

  /* Fall out and copy the tail.  */
}
</code></pre>

<p>/* There are just a few bytes to copy.  Use byte memory operations.  */
  BYTE_COPY_FWD (dstp, srcp, len);</p>

<p>return dstpp;
}
```</p>

<p>苹果darwin内核xnu</p>

<p>``` c memcpy http://www.opensource.apple.com/source/xnu/xnu-2050.18.24/libsyscall/wrappers/memcpy.c
typedef int word;       /* “word” used for optimal copy speed */</p>

<h1 id="define-wsize---sizeofword">define wsize   sizeof(word)</h1>
<p>#define wmask   (wsize - 1)</p>

<p>/*
 * Copy a block of memory, handling overlap.
 * This is the routine that actually implements
 * (the portable versions of) bcopy, memcpy, and memmove.
 */
<strong>private_extern</strong>
void * memcpy(void *dst0, const void *src0, size_t length)
{
    char *dst = dst0;
    const char *src = src0;
    size_t t;</p>

<pre><code>if (length == 0 || dst == src)      /* nothing to do */
    goto done;

/*
 * Macros: loop-t-times; and loop-t-times, t&gt;0
 */ #define TLOOP(s) if (t) TLOOP1(s) #define TLOOP1(s) do { s; } while (--t)

if ((unsigned long)dst &lt; (unsigned long)src) {
    /*
     * Copy forward.
     */
    t = (uintptr_t)src; /* only need low bits */
    if ((t | (uintptr_t)dst) &amp; wmask) {
        /*
         * Try to align operands.  This cannot be done
         * unless the low bits match.
         */
        if ((t ^ (uintptr_t)dst) &amp; wmask || length &lt; wsize)
            t = length;
        else
            t = wsize - (t &amp; wmask);
        length -= t;
        TLOOP1(*dst++ = *src++);
    }
    /*
     * Copy whole words, then mop up any trailing bytes.
     */
    t = length / wsize;
    TLOOP(*(word *)dst = *(word *)src; src += wsize; dst += wsize);
    t = length &amp; wmask;
    TLOOP(*dst++ = *src++);
} else {
    /*Copy backwords.*/ 
    /*...pass...*/
} done:
return (dst0); } ```
</code></pre>

<p>算法的精髓在于确定一个<strong>合适</strong>的近似迭代初值，通过有限次牛顿逼近得到精度范围允许的结果。</p>

<h6 id="newton-raphson-method">2.2 化曲为直：牛顿法(<strong>Newton-Raphson Method</strong>)</h6>

<image src="http://guevara.github.io/images/NewtonIteration_Ani.gif" width="400" height="300" />

<p>已知浮点数<script type="math/tex">x > 0</script>，欲计算<script type="math/tex">y = {\sqrt x}</script>，定义函数<script type="math/tex">f(y) = \frac{1}{y^2} - x = 0</script>，问题转换为求<script type="math/tex">f(x)</script>的<em>正数根</em>。
代入迭代公式</p>

<script type="math/tex; mode=display">
y_{n+1} = y_{n} - \frac{f(y_n)}{f'(y_n)}
</script>

<p>有</p>

<script type="math/tex; mode=display">
y_{n+1} = \frac{y_{n}(3-xy_n^2)}{2} \label{eq:ref10}
</script>

<p>，其中<script type="math/tex">f(y)=\frac{1}{y^2}-x</script>，<script type="math/tex">f'(y)=\frac{-2}{y^3}</script>。整理<script type="math/tex">\eqref{eq:ref10}</script>得</p>

<script type="math/tex; mode=display">
y_{n+1} = \frac{y_{n}(3-xy_n^2)}{2} = y_{n}(1.5-\frac{xy_n^2}{2})
</script>

<p>，迭代一次即代码第12行</p>

<p><code>c q_math.c  start:11 mark:12
    y  = * ( float * ) &amp;i;
    y  = y * ( threehalfs - ( x2 * y * y ) );   // 1st iteration
//  y  = y * ( threehalfs - ( x2 * y * y ) );   // 2nd iteration, this can be removed
</code></p>

<h4 id="section-4">2.3 美好开始：初值<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></h4>

<p>接下需要确定迭代公式的近似初值<script type="math/tex">y_{0}</script>。</p>

<p>32位浮点数</p>

<p>已知32位浮点数IEEE-754二进制表示形式</p>

<table>
  <tbody>
    <tr>
      <td>S(ign)</td>
      <td>E(xponent)</td>
      <td>M(antissa)</td>
    </tr>
    <tr>
      <td>1 bit</td>
      <td>8 bits</td>
      <td>23 bits</td>
    </tr>
    <tr>
      <td>bit 31</td>
      <td>30 ← bits → 23</td>
      <td>30 ← bits → 23</td>
    </tr>
  </tbody>
</table>

<p>其中<code>S</code>为符号位，<code>E</code>为经过偏移的8位指数，剩下23位为尾数<code>M</code>。浮点数值则表示成</p>

<script type="math/tex; mode=display">
x = {\left( { - 1} \right)^S}\left( {1.M} \right){2^{E - B}}
</script>

<p>对应整数值</p>

<script type="math/tex; mode=display">
I = S \cdot {2^{31}} + E \cdot {2^{23}} + M
</script>

<p><script type="math/tex">m</script>和<script type="math/tex">M</script>，<script type="math/tex">e</script>和<script type="math/tex">E</script>之间具有转换关系</p>

<script type="math/tex; mode=display">
\left\{
\begin{array}{c}
m = \frac{M}{L}, m \in \left[ 0, 1 \right ) \\
e = E - B
\end{array}
\right.
</script>

<p>其中偏移量<script type="math/tex">B = 2^{b-1} - 1</script>, 基底<script type="math/tex">L = 2^{n-b-1}</script>。对于32位浮点数，<script type="math/tex">B = 2^{7} - 1 = 127</script>，<script type="math/tex">L = 2^{23} </script>。</p>

<p>相应地推广至具有b位指数的n位二进制浮点数, <script type="math/tex">x</script>和<script type="math/tex">I_x</script>分别为</p>

<script type="math/tex; mode=display">
\left\{
\begin{array}{c}
x = \left( {1 + {m_x}} \right)2^{e_x}\\
{I_x} = {E_x}L + {M_x}
\end{array}
\right.
</script>

<p>对于给定参数<script type="math/tex">x</script>，其平方根倒数为</p>

<script type="math/tex; mode=display">
y = \frac{1}{\sqrt x } = x^{-\frac{1}{2}}
</script>

<p>等式两边同时取基底2的对数，</p>

<script type="math/tex; mode=display">
{\log _2}y =  - \frac{1}{2}{\log _2}x
</script>

<p>代入<script type="math/tex">x</script>和<script type="math/tex">y</script>的浮点形式，</p>

<script type="math/tex; mode=display">
{\log _2}\left( {1 + {m_y}} \right) =  - \frac{1}{2}{\log _2}\left( {1 + {m_x}} \right) - \frac{1}{2}{e_x}
</script>

<p>两边具有同类项</p>

<script type="math/tex; mode=display">\log \left( {1 + x} \right ) </script>

<p>已知当<script type="math/tex">0 \le x \le 1</script>，有<script type="math/tex">\log \left( {1 + x} \right ) \approx x </script>。令<script type="math/tex">{\log _2} \left( {1 + x} \right) \cong x + \sigma</script>，
<script type="math/tex">\sigma</script>为某个常量(事实上两端不尽相同)。这样上式可以简化成线性形式</p>

<script type="math/tex; mode=display">
{m_x} + \sigma  + {e_y} \approx  - \frac{1}{2}\left( {m_x} + \sigma  + {e_x} \right)
</script>

<p>代入</p>

<script type="math/tex; mode=display">
\begin{array}{l}
\frac{M_y}{L} + \sigma  + {E_y} - B \approx  - \frac{1}{2}\left( {\frac{M_x}{L} + \sigma  + {E_x} - B} \right)\\
 \Rightarrow \frac{M_y}{L} + {E_y} \approx  - \frac{1}{2}\left( {\frac{M_x}{L} + {E_x}} \right) - \frac{3}{2}\left( {\sigma  - B} \right)\\
 \Rightarrow {M_y} + L{E_y} \approx \frac{3}{2}L\left( {B - \sigma} \right) - \frac{1}{2}\left( {M_x} + L{E_x} \right)
\end{array}
</script>

<p>由此可得 <script type="math/tex"> {I_y} = R - \frac{1}{2}{I_x} </script>，此处<script type="math/tex">R = \frac{3}{2}\left( {B - \sigma } \right)L</script>。</p>

<p>方程</p>

<script type="math/tex; mode=display">
y_{0} = {I_y} = R - \frac{1}{2}{I_x} \label{ref1}
</script>

<p>刚好对应魔幻代码</p>

<p><code>c
    i  = 0x5f3759df - ( i &gt;&gt; 1 );
</code></p>

<h4 id="section-5">2.4 魔法数字之谜：误差分析<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></h4>

<p><script type="math/tex">\eqref{ref1}</script>式魔法数字R二进制表示为</p>

<table>
  <tbody>
    <tr>
      <td>0</td>
      <td>R1</td>
      <td>R2</td>
    </tr>
  </tbody>
</table>

<p>同理，给定浮点数<script type="math/tex">x > 0</script>(代码中为变量<code>i</code>和<code>number</code>)，二进制表示为</p>

<table>
  <tbody>
    <tr>
      <td>0</td>
      <td>E</td>
      <td>M</td>
    </tr>
  </tbody>
</table>

<p>接下来分别就<code>E</code>奇偶两种情况讨论。为统一起见，下面视尾数<code>M</code>和<code>R2</code>为浮点小数，即</p>

<script type="math/tex; mode=display">
\left\{
\begin{array}{c}
M \leftarrow m = \frac{M}{L} \\
R_{2} \leftarrow r_{2} = \frac{R_{2}}{L}
\end{array}
\right.
</script>

<h5 id="e">2.4.1 指数E为偶数</h5>

<p>指数E为偶数，<script type="math/tex">\left\lfloor E / 2 \right\rfloor = E / 2</script>，此时<script type="math/tex">e = E - 127 = 2d + 1</script>为奇数，
对于<code>i &gt;&gt; 1</code>操作，指数<code>E</code>没有有效位右移至尾数<code>M</code>，由此可得初值<script type="math/tex">y_{0}</script>的指数部分</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{align}
R_{1} - \left\lfloor \frac{E}{2} \right\rfloor &= R_{1} - \frac{E}{2} \\
    &= R_{1} - \frac{e + 127}{2} \\
    &= R_{1} - \frac{2d + 1 + 127}{2} \\
    & = R_{1} - 64 - d \\
    & > 0
\end{align}
 %]]&gt;</script>

<p><script type="math/tex">\forall E\in \left[ 0..254 \right]</script>，指数之差<script type="math/tex"> R_{1} - \left\lfloor \frac{E}{2} \right\rfloor \gt 0 </script>。如果为负，则符号位为1，而平方根倒数不可为负数。如果为0，尾数部分作减法必要时可能得从指数部分借位。
故<script type="math/tex">R_{1} \ge 128</script>。同样地有<script type="math/tex">y_{0}</script>的尾数部分<script type="math/tex">R - \left\lfloor M / 2 \right\rfloor</script>(计算时视为整数)，当<script type="math/tex">R_{2} \ge \left\lfloor M / 2 \right\rfloor</script>，
综上得</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{align}
y_{0} &= \left( 1 + R_{2} - \frac{M}{2} \right)2^{\left( R_{1} - 64 -d \right) - 127} \\
    &= \left( 1 + R_{2} - \frac{M}{2} \right)2^{\left( R_{1} - 191 -d \right)} \\
    &= \left( 2 + R_{2} - \frac{M}{2} \right)2^{\left( R_{1} - 192 -d \right)} \label{ref2}
\end{align} 
 %]]&gt;</script>

<p>注意<script type="math/tex">M / 2 = \left\lfloor M / 2 \right\rfloor</script>，因为<script type="math/tex">M</script>视为小数时两者之差不超过<script type="math/tex">2^{-24}</script>。
当<script type="math/tex">R_{2} \lt M / 2</script>，尾数从指数借一位，相当于<script type="math/tex">y_{0}</script>的值减半。
有借位时尾数变成<script type="math/tex">\left( 1 + R_{2} - \left\lfloor M /2 \right\rfloor \right)</script>，仍位于区间<script type="math/tex">\left[0, 1\right)</script>。同样地有初值</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{align}
y_{0} &= \left( 1 + \left( 1 + R_{2} - \frac{M}{2} \right)\right)2^{\left( R_{1} - 64 -d\right) - 127 -1} \\
    &= \left( 2 + R_{2} - \frac{M}{2} \right)2^{\left( R_{1} - 192 -d\right) } \label{ref3}
\end{align} 
 %]]&gt;</script>

<p>，尾数统一成和没有借位的情况一样。</p>

<p>定义公共项</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

{\beta}_{ M }^{ R_{2}} = \left\{
\begin{array}{c}
2R_{2} - M &: R_{2} \ge M / 2 \\
R_{2} - M/2 &: R_{2} \lt M 
\end{array}
\right.
 %]]&gt;</script>

<p><script type="math/tex">\eqref{ref2}</script>式和<script type="math/tex">\eqref{ref3}</script>式中的<script type="math/tex">y_{0}</script>合并成统一表示：</p>

<script type="math/tex; mode=display">
y_{ 0 }=\left( 2+{ \beta }_{ M }^{ R_{ 2 } } \right) 2^{ { R_{ 1 }-192-d } }
</script>

<p>注意<script type="math/tex">{ \beta  }_{ M }^{ R_{ 2 } }</script>是连续函数，除去<script type="math/tex">R = M / 2</script>点在其定义域可导。代入<script type="math/tex">e = 2d + 1</script>，<script type="math/tex">y = \frac{1}{\sqrt{x}}</script>的近似值为</p>

<script type="math/tex; mode=display">
\frac{1}{\sqrt{1 + M}} 2^{-e/2} = \frac{1}{\sqrt{1 + M}} 2^{-d - 1/2} = \frac{1}{\sqrt{2} \sqrt{1+M}} 2^{-d}
</script>

<p>引入相对误差<script type="math/tex">\left\lvert \frac{y - y_{0}}{y} \right\rvert</script>作为精度评估标准，</p>

<script type="math/tex; mode=display">
\left\lvert \frac{\frac{1}{\sqrt{2} \sqrt{1+M}} 2^{-d} - \left( 2+{ \beta }_{ M }^{ R_{ 2 } } \right) 2^{ { R_{ 1 }-192-d } } }{\frac{1}{\sqrt{2} \sqrt{1+M}} 2^{-d}} \right\rvert
</script>

<p>化简为<script type="math/tex">\left\lvert \varepsilon _{0} \left ( M, R \right )  \right\rvert</script>，</p>

<script type="math/tex; mode=display">
\varepsilon _{0} \left ( M, R \right ) = 1 - \sqrt{2} \sqrt(1 + M) \left( 2 + \beta_{M}^{R_{2}} \right) 2^{R_{1} - 192}
</script>

<p>为关于<script type="math/tex">M</script>的减函数，其中<script type="math/tex">M \in I = \left[0, 1 \right)</script>。函数与<script type="math/tex">d</script>无关，但仅当<script type="math/tex">E</script>为偶数时成立，故隐式地依赖于<script type="math/tex">E</script>。</p>

<p>假设相对误差<script type="math/tex">% &lt;![CDATA[
\max _{ M \in I }{\left\lvert \varepsilon _{0} \right\rvert} < 1/8 %]]&gt;</script>，即</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{align}
\frac{1}{8} & \gt \max _{M \in I}{\left\lvert \varepsilon _{0} \right\rvert} \\
            & \ge \left\lvert \varepsilon _{0} \right\rvert \\
            & = \left\lvert 1 - \sqrt{2} \left( 2 + 2R_{2} \right) 2^{R_{1} - 192} \right\rvert \\
            & = \left\lvert 1 - \left( 1 + R_{2} \right) 2^{R_{1} - 190.5} \right\rvert
\end{align}
 %]]&gt;</script>

<p>展开得，</p>

<script type="math/tex; mode=display">
\begin{align}
\frac{1}{8} \lt 1 - \left( 1 + R_{2} \right)2^{R_{1} - 190.5} \lt \frac{1}{8} \\
\end{align}
</script>

<script type="math/tex; mode=display">
\begin{align}
\frac{9}{8} \ge \frac{9}{8 \left ( 1 + R_{2} \right )} \gt 2^{R_{1} - 190.5} \gt \frac{7}{8 \left ( 1 + R_{2} \right ) } \gt \frac{7}{16}
\end{align}
</script>

<p>两边同时取对数<script type="math/tex">log_{2}</script>并加上<script type="math/tex">190.5</script>，<script type="math/tex">190.7 \gt 189.2</script>，位于该区间的唯一整数是</p>

<script type="math/tex; mode=display">
R_{1} = 190 = 0xbe
</script>

<p>当<script type="math/tex">E</script>为偶数的情况下可以确保误差控制在<script type="math/tex">0.125</script>以内。</p>

<h5 id="e-1">2.4.2 指数E为奇数</h5>

<p>顺着上面的思路，我们来分析一类更复杂的情况。区别在于代码<code>i&gt;&gt;1</code>将指数E的奇数低位移入尾数的高位。
这意味着移位后的实数值加上$1/2$变成<script type="math/tex">\left\lfloor M/2 \right\rfloor + 1/2</script>。<script type="math/tex">e = E - 127 = 2d</script>为奇数，同上得</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{align}
R_{1} - \left\lfloor \frac{E}{2} \right\rfloor &= R_{1} -  \left\lfloor \frac{e + 127}{2} \right\rfloor \\
    &= R_{1} -  \left\lfloor \frac{2d + 127}{2} \right\rfloor \\
    &= R_{1} - 63 - d
\end{align}
 %]]&gt;</script>

<p>大于0。</p>

<p>用<script type="math/tex">M/2</script>替换<script type="math/tex">\left\lfloor M/2 \right\rfloor</script>。尾数部分变成<script type="math/tex">R_{2} - (M/2 + 1/2)</script>，当<script type="math/tex">R_{2} \ge \frac{M+1}{2}</script>，不会像指数部分产生
借位。故有</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{align}
y_{0} &= \left( 1 + R_{2} - \left( \frac{M}{2} + \frac{1}{2} \right) \right)2^{\left( R_{1} - 63 -d \right) - 127} \\
    &= \left( \frac{1}{2} + R_{2} - \frac{M}{2} \right)2^{\left( R_{1} - 190 -d \right)} \\
    &= \left( 2 + 4R_{2} - 2M \right)2^{\left( R_{1} - 192 -d \right)}
\end{align}
 %]]&gt;</script>

<p>当<script type="math/tex">R_{2} \lt \frac{M + 1}{2}</script>，<code>R - (i &gt;&gt; 1)</code>将从指数部分借位，相当于<script type="math/tex">y_{0}</script>除以2，即尾数变成<script type="math/tex">1 + R_{2} -(\frac{M}{2} + \frac{1}{2})</script>
仍属于<script type="math/tex">I</script>。此时</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{align}
y_{0} &= \left( 1 + \left( 1 + R_{2} - \left( \frac{M}{2} + \frac{1}{2} \right) \right) \right)2^{\left( R_{1} - 63 -d \right) - 127 - 1} \\
    &= \left( \frac{3}{2} + R_{2} - \frac{M}{2} \right)2^{\left( R_{1} - 191 -d \right)} \\
    &= \left( 3 + 2R_{2} - M \right)2^{\left( R_{1} - 192 -d \right)}
\end{align}
 %]]&gt;</script>

<p>同<script type="math/tex">\beta_{M}^{R_{2}}</script>定义</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

{\gamma}_{ M }^{ R_{2}} = \left\{
\begin{array}{c}
4R_{2}-2M &: 2R_{2} \ge M + 1 \\
1 + 2R_{2} - M &: 2R_{2} \lt M + 1
\end{array}
\right.
 %]]&gt;</script>

<p>两个<script type="math/tex">y_{0}</script>统一写成</p>

<script type="math/tex; mode=display">
y_{0} = \left( 2 + \gamma_{M}^{R_{2}} \right)2^{R_{1} - 192 - d}
</script>

<p>注意<script type="math/tex">{ \beta  }_{ M }^{ R_{ 2 } }</script>是连续函数，除去<script type="math/tex">R = M / 2</script>点在其定义域可微。代入<script type="math/tex">e = 2d </script>，<script type="math/tex">y = \frac{1}{\sqrt{x}}</script>的近似值为</p>

<script type="math/tex; mode=display">
\frac{1}{\sqrt{1 + M}} 2^{-e/2} = \frac{1}{\sqrt{1 + M}} 2^{-d - 1/2} = \frac{1}{\sqrt{2} \sqrt{1+M}} 2^{-d}
</script>

<p>和<script type="math/tex">E</script>为偶数的近似值，缩小<script type="math/tex">\sqrt{2}</script></p>

<p>相对误差<script type="math/tex">\left\lvert \varepsilon _{0} \left ( M, R \right )  \right\rvert</script>化简为</p>

<script type="math/tex; mode=display">
\varepsilon _{1} \left ( M, R \right ) = 1 - \sqrt{1 + M} \left( 2 + \gamma_{M}^{R_{2}} \right) 2^{R_{1} - 192}
</script>

<p>与d无关（同样地隐式地与<script type="math/tex">E</script>有关）。</p>

<p>误差分析同上。以<script type="math/tex">R_{1} = 190 = 0xbe</script>为基准，重新定义误差函数如下</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{align}
\varepsilon _{0} \left ( M, R_{2} \right ) &= 1 - \sqrt{2} \sqrt{1 + M} \left( 2 + \beta_{M}^{R_{2}} \right) \\
\varepsilon _{1} \left ( M, R_{2} \right ) &= 1 - \sqrt{1 + M} \left( 2 + \gamma_{M}^{R_{2}} \right)
\end{align}
 %]]&gt;</script>

<p>仅与<script type="math/tex">M</script>和<script type="math/tex">R_{2}</script>，均属于区间<script type="math/tex">I</script>。</p>

<h5 id="section-6">例二</h5>
<p>当<script type="math/tex">x = 16</script>，有<script type="math/tex">E = 4 + 127 = 131</script>为奇数，<script type="math/tex">M = 0</script>，<script type="math/tex">x</script>右移一位则指数末位移入尾数高位。
执行<code>i  = 0x5f3759df - ( i &gt;&gt; 1 );</code>后近似初值<script type="math/tex">y_{0}</script>为<code>0x3e7759df</code>。相减之后生成新指数
<script type="math/tex">190 - \left \lfloor 131/2 \right \rfloor = 125 = 0x7d</script>，即<script type="math/tex">e = 125 - 127 = -2</script>。
新尾数从新指数借入一位，致使<script type="math/tex">e = -3</script>，以及新尾数<script type="math/tex">0xb759df - 0x4000000 = 0x7759df</script>，对应<script type="math/tex">M = 0.932430148</script>。
故<script type="math/tex">y_{0} = (1 + M)2^{-3} = 0.241553</script>，非常接近<script type="math/tex">\frac{1}{\sqrt{x}} = 0.25</script>。</p>

<p><blockquote><p>致广大而尽精微</p></blockquote></p>

<h4 id="section-7">2.5 尾数优化</h4>

<p>尾数优化在于最小化<script type="math/tex">\max _{ M\in I }{\left\lvert \varepsilon _{0} \left ( M, R_{2} \right ) \right\rvert, \left\lvert \varepsilon _{1} \left ( M, R_{2} \right ) \right\rvert  }</script>。由于<script type="math/tex">\varepsilon_{0}</script>和<script type="math/tex">\varepsilon_{1}</script>连续且分段可导，因此<script type="math/tex">M</script>值出现在分段区间的端点或者驻点。</p>

<h5 id="leftlvert-varepsilon-0-rightrvert">2.5.1 求<script type="math/tex">\left\lvert \varepsilon _{0} \right\rvert</script>最大值</h5>
<p>考察端点：<script type="math/tex">M = 0</script>，<script type="math/tex">M = 1</script>和<script type="math/tex">R_{2} = M / 2</script>（该点<script type="math/tex">\beta_{M}^{R_{2}}</script>不可导）。
当<script type="math/tex">M = 0</script>，<script type="math/tex">\beta_{M}^{R_{2}} = 2R_{2}</script>，则</p>

<script type="math/tex; mode=display">
f_{1} \left ( R_{2} \right ) = \varepsilon _{0} \left ( 0, R_{2} \right ) = 1 - \sqrt{2} \sqrt{1 + 0} \left ( 2 + 2R_{2} \right ) / 4 = 1 - \frac{1 + R_{2}}{\sqrt{2}}
</script>

<p>类似地，当<script type="math/tex">R_{2} = M / 2</script>，<script type="math/tex">\beta_{M}^{R_{2}} = 0</script>，有</p>

<script type="math/tex; mode=display">
f_{2} \left ( R_{2} \right ) = \varepsilon _{0} \left ( R_{2}, R_{2} \right ) = 1 - \sqrt{2} \sqrt{1 + 2R_{2}} \left ( 2 + 0 \right ) / 4 = 1 - \sqrt{\frac{1 + 2R_{2}}{2}}
</script>

<p>当<script type="math/tex">M = 1</script>分情况考虑<script type="math/tex">\beta_{ M }^{ R_{2}}</script></p>

<script type="math/tex; mode=display">% &lt;![CDATA[

f_{2} \left ( R_{2} \right ) = \varepsilon _{0} \left (1, R_{2} \right ) = 
\left\{
\begin{array}{c}
\frac{1}{2} \left ( 1 - 2R_{2} \right ) &: R_{2} \ge 1/2 \\
\frac{1}{4} \left ( 1 - 2R_{2} \right ) &: R_{2} \lt 1/2
\end{array}
\right.
 %]]&gt;</script>

<p>再分情况考察驻点。假设<script type="math/tex">R_{2} \ge M / 2</script>，解方程<script type="math/tex">\frac{\partial \varepsilon _{0}}{\partial M} = 0</script></p>

<script type="math/tex; mode=display">
\begin{align}
\frac{\partial \left ( 1 - \sqrt{2} \sqrt{1 + M} \left ( 2 + \beta_{M}^{R_{2}} \right ) / 4 \right ) }{\partial M} = 0 \\
\frac{\partial \sqrt{1 + M} \left ( 2 + \beta_{M}^{R_{2}} \right ) }{\partial M} = 0 \\
\end{align}
</script>

<p>代入<script type="math/tex">\beta_{M}^{R_{2}} = 2 R_{2} - M</script>，</p>

<script type="math/tex; mode=display">
\frac{1}{2}(1 + M)^{-\frac{1}{2}} \left ( 1 + 2R_{2} - M  \right ) - (1 + M)^{\frac{1}{2}} = 0
</script>

<p>得驻点<script type="math/tex">M = \frac{2}{3}R_{2}</script>，</p>

<script type="math/tex; mode=display">
f_{4} \left ( R_{2} \right ) = \varepsilon _{0} \left (\frac{2R_{2}}{3}, R_{2} \right ) = 1 - \frac{\left ( 1 + \frac{2}{3} R_{2} \right ) ^ {\frac{3}{2}} }{\sqrt{2}}
</script>

<p><script type="math/tex">R_{2} \lt M/2</script>时，<script type="math/tex">\beta_{M}^{R_{2}} = R_{2} - M / 2</script>，</p>

<script type="math/tex; mode=display">
\frac{1}{2}(1 + M)^{-\frac{1}{2}} \left ( 1 + R_{2} - \frac{M}{2}  \right ) - \frac{1}{2} (1 + M)^{\frac{1}{2}} = 0
</script>

<p>驻点为<script type="math/tex">M = \frac{2}{3} \left ( 1 + R_{2} \right )</script>。不过只对<script type="math/tex">R_{2} \in \left [ 0, \frac{1}{2} \right )</script>有效，故有</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

f_{5} \left ( R_{2} \right ) = 
\left\{
\begin{array}{c}
0 &: R_{2} \ge 1/2 \\
\varepsilon _{0} \left ( \frac{2}{3} \left ( 1 + R_{2} \right ), R_{2}\right ) = 1 - \frac{\left ( 5 + 2R_{2} \right )^{3/2}}{6\sqrt{6}} &: R_{2} \lt 1/2
\end{array}
\right.
 %]]&gt;</script>

<h5 id="leftlvert-varepsilon-1-rightrvert">2.5.2 求<script type="math/tex">\left\lvert \varepsilon _{1} \right\rvert</script>最大值</h5>

<p>分析过程同上，</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{align}
f_{6} \left ( R_{2} \right ) = \varepsilon _{1} \left (0, R_{2} \right ) = 
\left\{
\begin{array}{c}
\frac{1}{2} - R_{2} &: R_{2} \ge 1/2 \\
\frac{1}{4} \left ( 1 - 2R_{2} \right ) &: R_{2} \lt 1/2
\end{array}
\right.

f_{7} \left ( R_{2} \right ) = \varepsilon _{1} \left (1, R_{2} \right ) = 
\left\{
\begin{array}{c}
1 - \sqrt{2}R_{2} &: R_{2} \ge 1 \\
1 - \left ( 1 - R_{2} \right ) / \sqrt{2} &: R_{2} \lt 1
\end{array}
\right.
\end{align}
 %]]&gt;</script>

<p>对于端点<script type="math/tex">R = \frac{M + 1} {2}</script>，<script type="math/tex">\gamma _{M} ^{R_{2}} = 2</script>，不过只对<script type="math/tex">R_{2} \ge 1/2</script>有效，该点</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{align}
f_{8} \left ( R_{2} \right ) = 
\left\{
\begin{array}{c}
\varepsilon _{1} \left ( 2R_{2} - 1, R_{2} \right ) = 1 - \sqrt{2R_{2}} &: R_{2} \ge 1/2 \\
0 &: R_{2} \lt 1/2
\end{array}
\right.
\end{align}
 %]]&gt;</script>

<p>驻点同样分两种情况。<script type="math/tex">R_{2} \ge M/2 + 1/2</script>时驻点为<script type="math/tex">M = \frac{2R_{2} - 1}{3}</script>，此时<script type="math/tex">R_{2} \ge \frac{1}{2}</script>；同样<script type="math/tex">R_{2} \lt \frac{M + 1}{2}</script>
处有驻点<script type="math/tex">M = \frac{2R_{2} + 1}{3}</script>，此时<script type="math/tex">R_{2} \lt \frac{1}{2}</script>。合二为一</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{align}
f_{9} \left ( R_{2} \right ) = 
\left\{
\begin{array}{c}
\varepsilon _{1} \left ( \frac{2R_{2} - 1}{3}, R_{2} \right ) = 1 - \left ( \frac{2}{3} \left ( 1 + R_{2} \right ) \right )^{3/2} &: R_{2} \ge 1/2 \\
\varepsilon _{1} \left ( \frac{2R_{2} + 1}{3}, R_{2} \right ) = 1 - \sqrt{2} \left ( \frac{2 + R_{2}}{3} \right )^{3/2} &: R_{2} \lt 1/2 \\
\end{array}
\right.
\end{align}
 %]]&gt;</script>

<p>注意除<script type="math/tex">f_{9}</script>以外所有<script type="math/tex">f_{i}</script>均连续。</p>

<image src="http://guevara.github.io/images/figures/figure1.jpg" width="400" height="300" />

<image src="http://guevara.github.io/images/figures/figure2.jpg" width="400" height="300" />

<p>所有最大值的最低点在<script type="math/tex">R_{2} = 0.45</script>附近，非常接近程序中的<code>0.432430148</code>。</p>

<script type="math/tex; mode=display">
r_{0} = 0.432744889959443195468521587014
</script>

<p>对应整数值<script type="math/tex">R_{2} = \left\lfloor 2^{23}r_{0} + 0.5 \right\rfloor = 0x37642f</script>。附加指数<script type="math/tex">R_{1} = 0xbe</script>，移后之位为<script type="math/tex">0x5f</script>，得到最优常数
$$
R = 0x5f37642f
$$</p>

<h5 id="section-8">3. 测试</h5>

<p>重写源码去掉牛顿逼近部分，保留计算近似初值部分</p>

<p><code>cpp 
float InvSqrtLinear(float x, int magic)
{
    float xhalf = 0.5f * x;
    int i = *(int*) &amp;x;         // get bits for floating value
    i = magic - (i&gt;&gt;1);         // gives initial guess y0
    x = *(float*) &amp;i;           // convert bits back to float
    return x;
}
</code></p>

<p>另分别执行一轮或两轮牛顿逼近（经过第二轮耗时不长而精度较高）。每个测试遍历所有浮点值，最大相对误差百分比如下</p>

<table>
  <tbody>
    <tr>
      <td>Value</td>
      <td>Predicted</td>
      <td>Tested</td>
      <td>1 Iteration</td>
      <td>2 Iterations</td>
    </tr>
    <tr>
      <td>0x5f3759df</td>
      <td>3.43758</td>
      <td>3.43756</td>
      <td>0.175228</td>
      <td>4.66e-004</td>
    </tr>
    <tr>
      <td>0x5f37642f</td>
      <td>3.42128</td>
      <td>3.42128</td>
      <td>0.177585</td>
      <td>4.77521e-004</td>
    </tr>
    <tr>
      <td>0x5f375a86</td>
      <td>3.43655</td>
      <td>3.43652</td>
      <td>0.175124</td>
      <td>4.65437e-004</td>
    </tr>
  </tbody>
</table>

<p>从上表可见第三个常数<script type="math/tex">0x5f375a86</script>最优。</p>

<h4 id="section-9">参考文献</h4>
<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>McEniry, Charles. <a href="http://www.daxia.com/bibis/upload/406Fast_Inverse_Square_Root.pdf">The Mathematics Behind the Fast Inverse Square Root Function Code</a><a href="#fnref:1" rel="reference">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>Lomont, Chris. <a href="http://www.lomont.org/Math/Papers/2003/InvSqrt.pdf">Fast Inverse Square Root</a><a href="#fnref:2" rel="reference">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译]快速斐波那契算法]]></title>
    <link href="http://guevara.github.io/blog/2014/05/03/fast-fibonacci/"/>
    <updated>2014-05-03T08:55:00+08:00</updated>
    <id>http://guevara.github.io/blog/2014/05/03/fast-fibonacci</id>
    <content type="html"><![CDATA[<div class="note info">
  <h5>摘要</h5>
  <p>本文译自<a href="http://hbfs.wordpress.com/2012/05/22/fast-fibonacci/" target="_blank" title="Fast Fibonacci">Fast Fibonacci</a></p>
</div>

<p><a href="http://en.wikipedia.org/wiki/Fibonacci_number">斐波那契数列</a>在诸多方面，从<a href="http://www.maths.surrey.ac.uk/hosted-sites/R.Knott/Fibonacci/fibnat.html#seeds">头状花序</a>到<a href="http://en.wikipedia.org/wiki/Universal_code_%28data_compression%29">通用编码</a>（如<a href="http://books.google.ca/books?id=81AfzW6vux4C&amp;pg=PA100&amp;lpg=PA100&amp;dq=%22taboo+codes%22&amp;source=bl&amp;ots=PVUooaK7Fm&amp;sig=hdBqPpvYlRNWskAMrVawTO6i_k4&amp;hl=en&amp;sa=X&amp;ei=P0WyT9qmLsqIgwfa34m7CQ&amp;redir_esc=y#v=onepage&amp;q=%22taboo%20codes%22&amp;f=false">禁忌编码</a>）表现出种种有趣的性质。研究高效计算斐氏数列的过程充满乐趣。</p>

<p>斐波那契数列的经典公式表示为如下递推形式：</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

F_n=\begin{cases}
    1 & \mathrm{if~}n\leqslant{2} \\
    F_{n-1}+F_{n-2} &\mathrm{otherwise}
\end{cases}
 %]]&gt;</script>

<p>由此引出其直观（朴素）的递归实现：</p>

<p><code>c
uint64_t fibo_rec(uint64_t n)
{
    if (n &lt;= 2)
        return 1;
    else
        return fibo_rec(n - 1) + fibo_rec(n - 2);
}
</code></p>

<p>看上去很完美，可是计算<script type="math/tex">F_n</script>的过程中产生了<script type="math/tex">O(F_n)</script>次递归调用！运行时间呈指数增长（因为<script type="math/tex">F_n \approx \phi^n</script>，其中<script type="math/tex">\phi=\frac{1}{2}(1+\sqrt{5})</script>为黄金比例）。</p>

<p>通过显式地优化尾递可以消除递归调用：</p>

<p>``` c
uint64<em>t fibo_iter(uint64_t n)
{
    uint64_t n</em>1 = 1, n_2 = 0;</p>

<pre><code>for (uint64_t i = 0; i &lt; n; i++)
{
    uint64_t t = n_1 + n_2;
    n_2 = n_1;
    n_1 = t;
}

return n_1; } ```
</code></pre>

<p>这次计算<script type="math/tex">F_n</script>的时间复杂度下降到<script type="math/tex">O(n)</script>，大大优于原始递归版本。迭代版本借助临时变量保存和，并使用移位寄存器将后继的<strong>斐波那契数列</strong>分别保存到<code>n_2</code>和<code>n_1</code>。有些人可能会忌讳临时变量，那么可以将上述代码重写为： </p>

<p>``` c
uint64<em>t fibo_iter_var(uint64_t n)
{
    uint64_t n</em>1 = 1, n_2 = 0;</p>

<pre><code>for (uint64_t i = 0; i &lt; n; i++)
{
    n_1 = n_1 + n_2;
    n_2 = n_1 - n_2;
}

return n_1; } ```
</code></pre>

<p><code>n_2 = n_1 - n_2</code>部分化简得<code>n_1</code>（<script type="math/tex">n_2 \gets n_1 - n_2</script>，即<script type="math/tex">n_2 \gets (n_1 + n_2) - n_2</script>，结果为<script type="math/tex">n_2 \gets n_1</script>）。此处我们通过额外操作抵消掉临时变量，好坏别当别论。</p>

<center>&#8258;</center>

<p>是否有进一步优化的空间？根据以往的经验，线性时间似乎是最好的结果。无独有偶，有些聪明的家伙发现矩阵</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\left[
    \begin{array}{cc}
       0 & 1 \\
       1 & 1 
    \end{array}
\right]
 %]]&gt;</script>

<p>具有“平移”并增加一个矢量分量的性质。比如</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\left[
    \begin{array}{cc}
        0 & 1 \\
        1 & 1
    \end{array}
\right]
\left[
    \begin{array}{c}
        a\\
        b
    \end{array}
\right]
=
\left[
    \begin{array}{cc}
        b\\
        a + b
    \end{array}
\right]
 %]]&gt;</script>

<p>看上去有几分眼熟吧。事实上我们将<code>a</code>代换为<script type="math/tex">F_ {n-2}</script>，<code>b</code>代换为<script type="math/tex">F_ {n-1}</script>，得</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\left[
    \begin{array}{cc}
        0 & 1\\
        1 & 1
    \end{array}
\right]
\left[
    \begin{array}{cc}
        F_{n-2}\\
        F_{n-1}
    \end{array}
\right]
=
\left[
    \begin{array}{cc}
        F_{n-2}\\
        F_{n-1} + F_{n-2}
    \end{array}
\right]
=
\left[
    \begin{array}{c}
        F_{n-1}\\
        F_n
    \end{array}
\right]
 %]]&gt;</script>

<p>有点眉目了！但这是基于已知<script type="math/tex">F_ {n-1}</script>和<script type="math/tex">F_ {n-2}</script>的前提下，一旦成立意味着存在（递归）分解形式：</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\left[
    \begin{array}{cc}
        0 & 1\\
        1 & 1
    \end{array}
\right]
\left[
    \begin{array}{cc}
        F_{n-2}\\
        F_{n-1}
    \end{array}
\right]
=
\left[
    \begin{array}{cc}
        0 & 1\\
        1 & 1
    \end{array}
\right]
\left[
    \begin{array}{cc}
        0 & 1\\
        1 & 1
    \end{array}
\right]
\left[
    \begin{array}{cc}
        F_{n-3}\\
        F_{n-2}
    \end{array}
\right]
 %]]&gt;</script>

<p>反复如此迭代到初始条件<script type="math/tex">F_1 = 1</script>和<script type="math/tex">F_2 = 1</script>，那么有</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\left[
    \begin{array}{cc}
        0 & 1\\
        1 & 1
    \end{array}
\right]^n
\left[
    \begin{array}{c}
        1\\
        1
    \end{array}
\right]
=
\left[
    \begin{array}{c}
        F_{n-1}\\
        F_{n}
    \end{array}
\right]
 %]]&gt;</script>

<p>矩阵运算似乎代价不菲，至少要进行线性次数的矩阵乘法。幸运的是不需要那么多次，我们有办法在<script type="math/tex">O(\lg n)</script>时间复杂度内计算出<script type="math/tex">A^n</script>（此处矩阵维数为常数<script type="math/tex">2 \times{2}</script>，故可视矩阵乘积为常量）。如何计算呢？且观察式子<script type="math/tex">x^5 = (x^2)^2x</script>和<script type="math/tex">x^7 =((x^2)x)^2x</script>。整数情况时<script type="math/tex">x^n</script>计算过程如下：</p>

<p><code>c
int expo(int x, int n)
{
    int t = 1;
    int y = x;
    while (n)
    {
        if (n &amp; 1)
            t *= y;
        y *= y;
        n &gt;&gt;= 1;
    }
    return t;
}
</code></p>

<p>矩阵计算方式同理可得。以上代码中<code>t</code>为乘积当前值，<code>y</code>为乘积“平方”。给定两个矩阵</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\left[
    \begin{array}{cc}
        a_t & b_t \\
        c_t & d_t
    \end{array}
\right]
 %]]&gt;</script>

<p>和</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\left[
    \begin{array}{cc}
        a_y & b_y \\
        c_y & d_y
    \end{array}
\right]
 %]]&gt;</script>

<p>第一个初始化为<strong>单位阵</strong>，第二个初始化为<strong>斐波那契矩阵</strong>。根据矩阵的对称性，<script type="math/tex">c_t</script>和<script type="math/tex">c_y</script>各自恒等于<script type="math/tex">b_t</script>和<script type="math/tex">b_y</script>，这两个变量可以分别消掉。</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\left[
    \begin{array}{cc}
        a_t & b_t \\
        c_t & d_t
    \end{array}
\right]
\left[
    \begin{array}{cc}
        a_y & b_y \\
        c_y & d_y
    \end{array}
\right]
=
\left[
    \begin{array}{cc}
        a_t a_y + b_t b_y & a_t b_y + b_t d_y\\
        --- & b_t b_y + d_t d_y
    \end{array}
\right]
 %]]&gt;</script>

<p>和</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\left[
    \begin{array}{cc}
        a_y & b_y \\
        c_y & d_y
    \end{array}
\right]^2
=
\left[
    \begin{array}{cc}
        a_y^2 + b_y^2 & b_y(a_y + d_y)\\
        --- & b_y^2 + d_y^2
    \end{array}
\right]
 %]]&gt;</script>

<p>其中虚线位置表示对称部分。将上述式子代入幂函数，将有</p>

<p>``` c
uint64_t fibo_expo(uint64_t n)
{
    uint64_t a_t = 1, b_t = 0, d_t = 1, // “1”
            a_y = 0, b_y = 1, d_y = 1; // “y”</p>

<pre><code>while (n)
{
    if (n &amp; 1)
    {
        // t*=y;
        uint64_t a = a_t * a_y + b_t * b_y;
        uint64_t b = a_t * b_y + b_t * d_y;
        uint64_t d = b_t * b_y + d_t * d_y;

        a_t = a;
        b_t = b;
        d_t = d;
    }

    //y*=y;
    uint64_t a = a_y * a_y + b_y * b_y;
    uint64_t b = b_y * (a_y + d_y);
    uint64_t d = b_y * b_y + d_y * d_y;

    a_y = a;
    b_y = b;
    d_y = d;

    n &gt;&gt;= 1;
}
return b_t; } ```
</code></pre>

<p>提取出公共子式，改变赋值顺序，消除多余的临时变量，得</p>

<p>``` c
uint64_t fibo_expo_var(uint64_t n)
{
    uint64_t a_t = 1, b_t = 0, d_t = 1, // “1”
            a_y = 0, b_y = 1, d_y = 1; // “y”</p>

<pre><code>while (n)
{
    if (n &amp; 1)
    {
        // t*=y;
        uint64_t bx = b_t * b_y;
        b_t = a_t * b_y + b_t * d_y;
        a_t = a_t * a_y + bx;
        d_t = bx + d_t * d_y;
    }

    //y*=y;
    uint64_t b2 = b_y * b_y;
    b_y *= (a_y + d_y);
    a_y = a_y * a_y + b2;
    d_y = b2 + d_y * d_y;

    n &gt;&gt;= 1;
}
return b_t; } ```
</code></pre>

<center>&#8258;</center>

<p>太棒了，我们找着了一个<script type="math/tex">O(\lg n)</script>的算法来计算斐波那契数列。不过仍有稍加改进的余地。再怎么改进呢？且注意，</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\left[
    \begin{array}{cc}
        a & b\\
        b & d
    \end{array}
\right]
=
\left[
    \begin{array}{cc}
        a & b\\
        b & a+b
    \end{array}
\right]
 %]]&gt;</script>

<p>这样一来消去变量<code>d</code>，得到仅包含变量<code>a</code>和<code>b</code>的方程。修改乘积项和平方项使其只包含变量<code>a</code>和<code>b</code>：</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\left[
    \begin{array}{cc}
        a_t & b_t\\
        b_t & a_t + b_t
    \end{array}
\right]
\left[
    \begin{array}{cc}
        a_y & b_y\\
        b_y & a_y + b_y
    \end{array}
\right]
=
\left[
    \begin{array}{cc}
        a_ta_y+b_t + b_y & a_tb_y + b_t(ay+b_y)\\
        --- & ---
    \end{array}
\right]
 %]]&gt;</script>

<p>以及</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\left[
    \begin{array}{cc}
        a_y & b_y\\
        b_y & d_y
    \end{array}
\right]^2
=
\left[
    \begin{array}{cc}
        a_y^2+b_y^2 & a_yb_y+b_y(a_y+b_y)\\
        --- & ---
    \end{array}
\right]
 %]]&gt;</script>

<p>其中虚线表示无需关心的部分。利用上述结果，可得：</p>

<p>``` c
uint64<em>t fibo_expo_var</em>2(uint64_t n)
{
    uint64_t a_t = 1, b_t = 0, // “1”
            a_y = 0, b_y = 1; // “y”</p>

<pre><code>while (n)
{
    if (n &amp; 1)
    {
        // t*=y;
        uint64_t bx = b_t * b_y;
        b_t = a_t * b_y + b_t * a_y + bx;
        a_t = a_t * a_y + bx;
    }

    //y*=y;
    uint64_t b2 = b_y * b_y;
    b_y = 2 * a_y * b_y + b2;
    a_y = a_y * a_y + b2;

    n &gt;&gt;= 1;
}
return b_t; } ```
</code></pre>

<p>这几个算法就运行速度比较结果如何？原始递归算法效率低得惊人，生成<script type="math/tex">F_ {50}</script>需要一分多钟，而其他算法只花费几微秒。进行10000000（1000万）次迭代测试（使用相同的随机输入，随机数<script type="math/tex">n</script>位于1到70之间），结果如下</p>

<table>
  <tbody>
    <tr>
      <td>iter</td>
      <td>3.29529s</td>
    </tr>
    <tr>
      <td>iter_var</td>
      <td>3.30153s</td>
    </tr>
    <tr>
      <td>expo</td>
      <td>2.28118s</td>
    </tr>
    <tr>
      <td>expo_var</td>
      <td>2.2531s</td>
    </tr>
    <tr>
      <td>expo_var_2</td>
      <td>2.22531s</td>
    </tr>
  </tbody>
</table>

<p><br />
最后三个版本的确快很多，但是快速乘幂算法版本之间的效率差距并不显著。假如改进程度相比迭代版本没有那么大的话，我们应该意识到刚只是计算相对较小的斐波那契数列。64位无符号整数最大仅允许存储<script type="math/tex">F_{92}</script>（因为<script type="math/tex">log_ \phi 2^{64} \approx 92</script>，<script type="math/tex">F_n \approx \phi^n</script>，所以两边取对数解出<script type="math/tex">n</script>，推出<script type="math/tex">\phi^n = 2^{64}</script>），不过通过大整数（抽象为类）来计算<script type="math/tex">F_{129713151}</script>，远比迭代方法和递归算法快得多得多。</p>
]]></content>
  </entry>
  
</feed>
